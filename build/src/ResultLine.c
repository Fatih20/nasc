/* ResultLine.c generated by valac 0.32.1, the Vala compiler
 * generated from ResultLine.vala, do not modify */

/*
 * Copyright (c) 2015 Peter Arnold
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_RESULT_LINE (result_line_get_type ())
#define RESULT_LINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RESULT_LINE, ResultLine))
#define RESULT_LINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RESULT_LINE, ResultLineClass))
#define IS_RESULT_LINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RESULT_LINE))
#define IS_RESULT_LINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RESULT_LINE))
#define RESULT_LINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RESULT_LINE, ResultLineClass))

typedef struct _ResultLine ResultLine;
typedef struct _ResultLineClass ResultLineClass;
typedef struct _ResultLinePrivate ResultLinePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

struct _ResultLine {
	GObject parent_instance;
	ResultLinePrivate * priv;
};

struct _ResultLineClass {
	GObjectClass parent_class;
};

struct _ResultLinePrivate {
	gint _line;
	gchar* _variable_name;
	gchar* _value;
	gchar* _full_value;
	cairo_t* context;
	gint width;
};


static gpointer result_line_parent_class = NULL;

GType result_line_get_type (void) G_GNUC_CONST;
#define RESULT_LINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_RESULT_LINE, ResultLinePrivate))
enum  {
	RESULT_LINE_DUMMY_PROPERTY,
	RESULT_LINE_LINE,
	RESULT_LINE_VARIABLE_NAME,
	RESULT_LINE_VALUE,
	RESULT_LINE_FULL_VALUE
};
ResultLine* result_line_new (gint line, const gchar* name, const gchar* value, gint width);
ResultLine* result_line_construct (GType object_type, gint line, const gchar* name, const gchar* value, gint width);
void result_line_set_line (ResultLine* self, gint value);
void result_line_set_variable_name (ResultLine* self, const gchar* value);
static void result_line_set_value (ResultLine* self, const gchar* value);
gboolean result_line_set_value_with_notification (ResultLine* self, const gchar* value);
const gchar* result_line_get_full_value (ResultLine* self);
static void result_line_set_full_value (ResultLine* self, const gchar* value);
void result_line_set_val (ResultLine* self, const gchar* value);
void result_line_refresh_width (ResultLine* self, gint width);
gint result_line_get_line (ResultLine* self);
const gchar* result_line_get_variable_name (ResultLine* self);
const gchar* result_line_get_value (ResultLine* self);
static void result_line_finalize (GObject* obj);
static void _vala_result_line_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_result_line_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


ResultLine* result_line_construct (GType object_type, gint line, const gchar* name, const gchar* value, gint width) {
	ResultLine * self = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	cairo_surface_t* source = NULL;
	cairo_surface_t* _tmp4_ = NULL;
	cairo_t* _tmp5_ = NULL;
	cairo_t* _tmp6_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (value != NULL, NULL);
	self = (ResultLine*) g_object_new (object_type, NULL);
	_tmp0_ = line;
	result_line_set_line (self, _tmp0_);
	_tmp1_ = name;
	result_line_set_variable_name (self, _tmp1_);
	_tmp2_ = value;
	result_line_set_value (self, _tmp2_);
	_tmp3_ = width;
	self->priv->width = _tmp3_;
	_tmp4_ = cairo_image_surface_create (CAIRO_FORMAT_A8, 32, 32);
	source = _tmp4_;
	_tmp5_ = cairo_create (source);
	_cairo_destroy0 (self->priv->context);
	self->priv->context = _tmp5_;
	_tmp6_ = self->priv->context;
	cairo_set_font_size (_tmp6_, (gdouble) 16);
	_cairo_surface_destroy0 (source);
	return self;
}


ResultLine* result_line_new (gint line, const gchar* name, const gchar* value, gint width) {
	return result_line_construct (TYPE_RESULT_LINE, line, name, value, width);
}


gboolean result_line_set_value_with_notification (ResultLine* self, const gchar* value) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (value != NULL, FALSE);
	_tmp0_ = value;
	_tmp1_ = self->priv->_full_value;
	if (g_strcmp0 (_tmp0_, _tmp1_) == 0) {
		result = FALSE;
		return result;
	}
	_tmp2_ = value;
	result_line_set_full_value (self, _tmp2_);
	_tmp3_ = value;
	result_line_set_val (self, _tmp3_);
	g_signal_emit_by_name (self, "changed");
	result = TRUE;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


void result_line_set_val (ResultLine* self, const gchar* value) {
	cairo_text_extents_t extents = {0};
	cairo_t* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	cairo_text_extents_t _tmp2_ = {0};
	cairo_text_extents_t _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	gint _tmp5_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->context;
	_tmp1_ = value;
	cairo_text_extents (_tmp0_, _tmp1_, &_tmp2_);
	extents = _tmp2_;
	_tmp3_ = extents;
	_tmp4_ = _tmp3_.width;
	_tmp5_ = self->priv->width;
	if (((gint) _tmp4_) > _tmp5_) {
		gchar* tmp = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		const gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		const gchar* _tmp32_ = NULL;
		_tmp6_ = value;
		_tmp7_ = g_strdup (_tmp6_);
		tmp = _tmp7_;
		while (TRUE) {
			cairo_text_extents_t _tmp8_ = {0};
			gdouble _tmp9_ = 0.0;
			gint _tmp10_ = 0;
			const gchar* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gchar* _tmp15_ = NULL;
			cairo_t* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			cairo_text_extents_t _tmp18_ = {0};
			_tmp8_ = extents;
			_tmp9_ = _tmp8_.width;
			_tmp10_ = self->priv->width;
			if (!(((gint) _tmp9_) > (2 * _tmp10_))) {
				break;
			}
			_tmp11_ = tmp;
			_tmp12_ = tmp;
			_tmp13_ = strlen (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = string_substring (_tmp11_, (glong) 0, (glong) (_tmp14_ / 2));
			_g_free0 (tmp);
			tmp = _tmp15_;
			_tmp16_ = self->priv->context;
			_tmp17_ = tmp;
			cairo_text_extents (_tmp16_, _tmp17_, &_tmp18_);
			extents = _tmp18_;
		}
		while (TRUE) {
			cairo_text_extents_t _tmp19_ = {0};
			gdouble _tmp20_ = 0.0;
			gint _tmp21_ = 0;
			const gchar* _tmp22_ = NULL;
			const gchar* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			gint _tmp25_ = 0;
			gchar* _tmp26_ = NULL;
			cairo_t* _tmp27_ = NULL;
			const gchar* _tmp28_ = NULL;
			cairo_text_extents_t _tmp29_ = {0};
			_tmp19_ = extents;
			_tmp20_ = _tmp19_.width;
			_tmp21_ = self->priv->width;
			if (!(((gint) _tmp20_) > _tmp21_)) {
				break;
			}
			_tmp22_ = tmp;
			_tmp23_ = tmp;
			_tmp24_ = strlen (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = string_substring (_tmp22_, (glong) 0, (glong) (_tmp25_ - 1));
			_g_free0 (tmp);
			tmp = _tmp26_;
			_tmp27_ = self->priv->context;
			_tmp28_ = tmp;
			cairo_text_extents (_tmp27_, _tmp28_, &_tmp29_);
			extents = _tmp29_;
		}
		_tmp30_ = tmp;
		_tmp31_ = g_strconcat (_tmp30_, "...", NULL);
		_g_free0 (tmp);
		tmp = _tmp31_;
		_tmp32_ = tmp;
		result_line_set_value (self, _tmp32_);
		_g_free0 (tmp);
	} else {
		const gchar* _tmp33_ = NULL;
		_tmp33_ = value;
		result_line_set_value (self, _tmp33_);
	}
}


void result_line_refresh_width (ResultLine* self, gint width) {
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = width;
	self->priv->width = _tmp0_;
	_tmp1_ = self->priv->_full_value;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = self->priv->_full_value;
		result_line_set_val (self, _tmp2_);
	}
}


gint result_line_get_line (ResultLine* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_line;
	result = _tmp0_;
	return result;
}


void result_line_set_line (ResultLine* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_line = _tmp0_;
	g_object_notify ((GObject *) self, "line");
}


const gchar* result_line_get_variable_name (ResultLine* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_variable_name;
	result = _tmp0_;
	return result;
}


void result_line_set_variable_name (ResultLine* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_variable_name);
	self->priv->_variable_name = _tmp1_;
	g_object_notify ((GObject *) self, "variable-name");
}


const gchar* result_line_get_value (ResultLine* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_value;
	result = _tmp0_;
	return result;
}


static void result_line_set_value (ResultLine* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_value);
	self->priv->_value = _tmp1_;
	g_object_notify ((GObject *) self, "value");
}


const gchar* result_line_get_full_value (ResultLine* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_full_value;
	result = _tmp0_;
	return result;
}


static void result_line_set_full_value (ResultLine* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_full_value);
	self->priv->_full_value = _tmp1_;
	g_object_notify ((GObject *) self, "full-value");
}


static void result_line_class_init (ResultLineClass * klass) {
	result_line_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ResultLinePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_result_line_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_result_line_set_property;
	G_OBJECT_CLASS (klass)->finalize = result_line_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), RESULT_LINE_LINE, g_param_spec_int ("line", "line", "line", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RESULT_LINE_VARIABLE_NAME, g_param_spec_string ("variable-name", "variable-name", "variable-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RESULT_LINE_VALUE, g_param_spec_string ("value", "value", "value", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), RESULT_LINE_FULL_VALUE, g_param_spec_string ("full-value", "full-value", "full-value", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("changed", TYPE_RESULT_LINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("destroy", TYPE_RESULT_LINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void result_line_instance_init (ResultLine * self) {
	self->priv = RESULT_LINE_GET_PRIVATE (self);
}


static void result_line_finalize (GObject* obj) {
	ResultLine * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_RESULT_LINE, ResultLine);
	_g_free0 (self->priv->_variable_name);
	_g_free0 (self->priv->_value);
	_g_free0 (self->priv->_full_value);
	_cairo_destroy0 (self->priv->context);
	G_OBJECT_CLASS (result_line_parent_class)->finalize (obj);
}


GType result_line_get_type (void) {
	static volatile gsize result_line_type_id__volatile = 0;
	if (g_once_init_enter (&result_line_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ResultLineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) result_line_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ResultLine), 0, (GInstanceInitFunc) result_line_instance_init, NULL };
		GType result_line_type_id;
		result_line_type_id = g_type_register_static (G_TYPE_OBJECT, "ResultLine", &g_define_type_info, 0);
		g_once_init_leave (&result_line_type_id__volatile, result_line_type_id);
	}
	return result_line_type_id__volatile;
}


static void _vala_result_line_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ResultLine * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_RESULT_LINE, ResultLine);
	switch (property_id) {
		case RESULT_LINE_LINE:
		g_value_set_int (value, result_line_get_line (self));
		break;
		case RESULT_LINE_VARIABLE_NAME:
		g_value_set_string (value, result_line_get_variable_name (self));
		break;
		case RESULT_LINE_VALUE:
		g_value_set_string (value, result_line_get_value (self));
		break;
		case RESULT_LINE_FULL_VALUE:
		g_value_set_string (value, result_line_get_full_value (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_result_line_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ResultLine * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_RESULT_LINE, ResultLine);
	switch (property_id) {
		case RESULT_LINE_LINE:
		result_line_set_line (self, g_value_get_int (value));
		break;
		case RESULT_LINE_VARIABLE_NAME:
		result_line_set_variable_name (self, g_value_get_string (value));
		break;
		case RESULT_LINE_VALUE:
		result_line_set_value (self, g_value_get_string (value));
		break;
		case RESULT_LINE_FULL_VALUE:
		result_line_set_full_value (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



